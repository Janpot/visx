webpackHotUpdate_N_E("pages/docs/xychart",{

/***/ "../../node_modules/raw-loader/dist/cjs.js!../visx-xychart/Readme.md":
/*!**********************************************************************************************************!*\
  !*** /Users/christopher-williams/dev/visx/node_modules/raw-loader/dist/cjs.js!../visx-xychart/Readme.md ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"# @visx/xychart\\n\\nIn contrast to other `visx` packages which are low-level, this package seeks to abstract some of the\\ncomplexity of common visualization engineering, and exposes a **high-level** x,y (cartesian\\ncoordinate) chart API. However, it is implemented using modularized `React.context` layers for\\ntheme, canvas dimensions, x/y/color scales, data, events, and tooltips which allows for more\\nexpressivity and advanced use cases.\\n\\nOut of the box it supports the following:\\n\\n- \\\\* many common `<*Series />` types (animated or not) such as lines, bars, etc.\\n- \\\\* `<Axis />` (animated or not)\\n- \\\\* `<Grid />` (animated or not)\\n- \\\\* `<Annotation />` (animated or not)\\n- \\\\* `<Tooltip />`\\n- \\\\* `theme`ing\\n\\nThe following illustrates basic usage to create an animated line chart with a bottom `Axis`, `Grid`,\\nand `Tooltip`, try it on codesandbox [here](todo, simplify code below):\\n\\n```tsx\\nimport {\\n  AnimatedAxis, // any of these can be non-animated equivalents\\n  AnimatedGrid,\\n  AnimatedLineSeries,\\n  XYChart,\\n} from '@visx/xychart';\\n\\nconst data1 = [\\n  { x: '2020-01-01', y: 50 },\\n  { x: '2020-01-02', y: 10 },\\n  { x: '2020-01-03', y: 20 },\\n  { x: '2020-01-04', y: 10 },\\n  { x: '2020-01-05', y: 0 },\\n];\\n\\nconst data2 = [\\n  { x: '2020-01-01', y: 30 },\\n  { x: '2020-01-02', y: 40 },\\n  { x: '2020-01-03', y: 80 },\\n  { x: '2020-01-04', y: 70 },\\n  { x: '2020-01-05', y: 20 },\\n];\\nconst accessors = {\\n  xAccessor: d => d.x,\\n  yAccessor: d => d.y,\\n};\\n\\nconst render = () => (\\n  <XYChart height={300} xScale={{ type: 'band' }} yScale={{ type: 'linear' }}>\\n    <AnimatedAxis orientation=\\\"bottom\\\" />\\n    <AnimatedGrid columns={false} numTicks={4} />\\n    <AnimatedLineSeries dataKey=\\\"Line 1\\\" data={data1} {...accessors} />\\n    <AnimatedLineSeries dataKey=\\\"Line 2\\\" data={data2} {...accessors} />\\n    <Tooltip\\n      snapTooltipToDatumX\\n      snapTooltipToDatumY\\n      showVerticalCrosshair\\n      showSeriesGlyphs\\n      renderTooltip={({ tooltipData, colorScale }) => (\\n        <div>\\n          <div style={{ color: colorScale(tooltipData.nearestDatum.key) }}>\\n            {tooltipData.nearestDatum.key}\\n          </div>\\n          {accessors.xAccessor(tooltipData.nearestDatum.datum)}\\n          {', '}\\n          {accessors.yAccessor(tooltipData.nearestDatum.datum)}\\n        </div>\\n      )}\\n    />\\n  </XYChart>\\n);\\n```\\n\\nExpand sections for more, or explore the detailed API below.\\n\\n<hr />\\n\\n## Basic usage\\n\\n<details>\\n  <summary>Series types</summary>\\n\\nThe following `Series` types are currently supported and we are happy to review or consider\\nadditional Series types in the future.\\n\\n| Component name        | Description                                                                                      | Usage                                                |\\n| --------------------- | ------------------------------------------------------------------------------------------------ | ---------------------------------------------------- |\\n| (Animated)AreaSeries  | Connect data points with a `<path />`, with a color fill to the zero baseline                    | `<AreaSeries />`                                     |\\n| (Animated)BarSeries   | Render a `<rect />` for each data point                                                          | `<BarSeries />`                                      |\\n| (Animated)BarGroup    | Group multiple child `<BarSeries />` values together                                             | `<BarGroup><BarSeries /><BarSeries />...</BarGroup>` |\\n| (Animated)BarStack    | Stack multiple child `<BarSeries />` values together                                             | `<BarStack><BarSeries /><BarSeries />...</BarStack>` |  |\\n| (Animated)GlyphSeries | Render a `Glyph` (any shape, defaults to `<circle />`) for each data point, e.g., a scatter plot | `<GlyphSeries renderGlyph={() => ...} />`            |\\n| (Animated)LineSeries  | Connect data points with a `<path>`                                                              | `<GlyphSeries />`                                    |\\n\\nAll `Series` have animated and non-animated variants to give you more control over your bundle size,\\nsupport missing (`null`) data, and can be rendered vertically or horizontally.\\n\\n</details>\\n\\n<details>\\n  <summary>Theming</summary>\\n\\nDefault `lightTheme` and `darkTheme` themes are exported from `@visx/xychart` and the utility\\n`buildChartTheme` is exported to support easy creation of custom themes.\\n\\n```ts\\nimport { buildTheme, XYChart } from '@visx/xychart';\\nimport { TextProps as SVGTextProps } from '@visx/text/lib/Text'; // just for types\\n\\nconst customTheme = buildTheme({\\n  // colors\\n  backgroundColor: string; // used by Tooltip, Annotation\\n  colors: string[]; // categorical colors, mapped to series via `dataKey`s\\n\\n  // labels\\n  svgLabelBig?: SVGTextProps;\\n  svgLabelSmall?: SVGTextProps;\\n  htmlLabel?: HTMLTextStyles;\\n\\n  // lines\\n  xAxisLineStyles?: LineStyles;\\n  yAxisLineStyles?: LineStyles;\\n  xTickLineStyles?: LineStyles;\\n  yTickLineStyles?: LineStyles;\\n  tickLength: number;\\n\\n  // grid\\n  gridColor: string;\\n  gridColorDark: string; // used for axis baseline if x/yxAxisLineStyles not set\\n  gridStyles?: CSSProperties;\\n});\\n\\n() => <XYChart theme={customTheme} />\\n```\\n\\n</details>\\n\\n<details>\\n  <summary>Tooltips</summary>\\n\\n`@visx/tooltip` `Tooltip`s are integrated into `@visx/xychart`, and should be rendered as a child of\\n`XYChart` (or a child where `TooltipContext` is provided).\\n\\n**`Tooltip` positioning** is handled by the `Tooltip` itself, based on `TooltipContext`. `Tooltip`\\nis rendered inside a `Portal`, avoiding clipping by parent DOM elements with higher z-index\\ncontexts. See the API below for a full list of `props` to support additional behavior, such as\\nsnapping to data point positions and rendering cross-hairs.\\n\\n**`Tooltip` content** is controlled by the specified `prop.renderTooltip` which has access to:\\n\\n- `tooltipData.nearestDatum` – the globally closest `Datum`, **across all** `Series`'s `dataKey`s\\n- `tooltipData.datumByKey` – the closest `Datum` **for each** `Series`'s `dataKey`; this enables\\n  \\\"shared tooltips\\\" where you can render the nearest data point for each `Series`.\\n- a shared `colorScale` which maps `Series`'s `dataKey`s to `theme` colors\\n\\n</details>\\n\\n<details>\\n  <summary>Event handlers</summary>\\n\\nThe following `PointerEvent`s (handling both `MouseEvent`s and `TouchEvent`s) are currently\\nsupported. They may be set on individual `Series` components (e.g.,\\n`<BarSeries onPointerMove={() => ...} />`), or at the chart level (e.g.,\\n`<XYChart onPointerMove={() => {}} />`) in which case they are invoked once for _every_ `*Series`.\\nTo **disable** event emitting for any `Series` set `<*Series enableEvents=false />`.\\n\\nBelow, `HandlerParms` has the following type signature:\\n\\n```ts\\ntype EventHandlerParams<Datum> = {\\n  datum: Datum; // nearest Datum to event, for Series with `dataKey=key`\\n  distanceX: number; // x distance between event and Datum, in px\\n  distanceY;: number; // y distance between event and Datum, in px\\n  event: React.PointerEvent | React.FocusEvent; // the event\\n  index: number; // index of Datum in Series `data` array\\n  key: string; // `dataKey` of Series to which `Datum` belongs\\n  svgPoint: { x: number; y: number }; // event position in svg-coordinates\\n};\\n```\\n\\n| Prop name       | Signature                                     | `XYChart` support | `*Series` support |\\n| --------------- | --------------------------------------------- | ----------------- | ----------------- |\\n| `onPointerMove` | `(params: EventHandlerParams<Datum>) => void` | ✅                | ✅                |\\n| `onPointerOut`  | `(event: React.PointerEvent) => void`         | ✅                | ✅                |\\n| `onPointerUp`   | `(params: EventHandlerParams<Datum>) => void` | ✅                | ✅                |\\n| `onFocus`       | `(params: EventHandlerParams<Datum>) => void` | ❌                | ✅                |\\n| `onBlur`        | `(event: React.TouchEvent) => void`           | ❌                | ✅                |\\n\\n</details>\\n\\n<details>\\n  <summary>Annotations</summary>\\n\\nComposable `@visx/annotations` annotations are integrated into `@visx/xychart` and use its theme and\\ndimension context. These components allow for annotation of individual points using\\n`AnnotationCircleSubject`, or x- or y-thresholds using `AnnotationLineSubject`.\\n\\n```tsx\\nimport {\\n  XYChart,\\n  AnimatedAnnotation,\\n  AnnotationLabel,\\n  AnnotationConnector,\\n  AnnotationCircleSubject,\\n} from '@visx/xychart';\\n\\nconst data = [\\n  { x: '2020-01-01', y: 50 },\\n  { x: '2020-01-02', y: 10 },\\n  { x: '2020-01-03', y: 20 },\\n];\\n\\n() => (\\n  <XYChart {...}>\\n    <LineSeries dataKey=\\\"line\\\" data={data} xAccessor={...} yAccessor={...} />\\n    <AnimatedAnnotation\\n      dataKey=\\\"line\\\" // use this Series's accessor functions, alternatively specify x/yAccessor here\\n      datum={data[0]}\\n      dx={labelXOffset}\\n      dy={labelYOffset}\\n      editable={isEditable}\\n      onDragEnd={({ x, y, dx, dy }) => /** handle edit */}\\n    >\\n      {/** Text label */}\\n      <AnnotationLabel title=\\\"My point\\\" subtitle=\\\"More deets\\\" />\\n      {/** Draw circle around point */}\\n      <AnnotationCircleSubject />\\n      {/** Connect label to CircleSubject */}\\n      <AnnotationConnector />\\n    </AnimatedAnnotation>\\n  </XYChart>\\n)\\n\\n```\\n\\n</details>\\n\\n<hr />\\n\\n## Advanced usage\\n\\n<details>\\n  <summary>Examples</summary>\\n\\n`XYChart` is implemented using modularized `React.context` layers for scales, canvas dimensions,\\ndata, events, and tooltips which enables more advanced usage than many other chart-level\\nabstractions.\\n\\nBy default `XYChart` renders all context providers if a given context is not available, but you can\\nshare context across multiple `XYChart`s to implement functionality such as linked tooltips, shared\\nthemes, or shared data.\\n\\n- 🔜 Custom chart background using theme and chart dimensions\\n- 🔜 Linked tooltips\\n- 🔜 Programmatically control tooltips\\n\\n</details>\\n\\n<details>\\n  <summary>DataContext</summary>\\n\\nThis context provides chart canvas dimensions (`width`, `height`, and `margin`), x/y/color scales,\\nand a data registry. The data registry includes data from all child `*Series`, and x/y/color scales\\nare updated accordingly accounting for canvas dimensions.\\n\\n</details>\\n\\n<details>\\n  <summary>ThemeContext</summary>\\n\\nThis context provides an `XYChart` theme, its used by all visual elements that compose a chart, and\\ncan be used to render custom visual elements that are on theme.\\n\\n</details>\\n\\n<details>\\n  <summary>EventEmitterContext</summary>\\n\\nThis context provides an event publishing / subscription object which can be used via the\\n`useEventEmitter` hook. `Series` and `XYChart` events, including tooltip updates, are emitted and\\nhandled with through this context.\\n\\n```tsx\\nimport { useEventEmitter, EventEmitterContext } from '@visx/xychart';\\n\\nconst eventSourceId = 'optional-source-id-filter';\\n\\n() => (\\n  <EventEmitterContext>\\n    {/** emit events */}\\n    {() => {\\n      const emit = useEventEmitter();\\n      return (\\n        <button onPointerUp={event => emit('pointerup', event, eventSourceId)}>emit event</button>\\n      );\\n    }}\\n    {/** subscribe to events */}\\n    {() => {\\n      const [clickCount, setClickCount] = useState(0);\\n      useEventEmitter('pointerUp', () => setClickCount(clickCount + 1), [eventSourceId]);\\n\\n      return <div>Pressed {clickCount} times</div>;\\n    }}\\n  </EventEmitterContext>\\n);\\n```\\n\\n</details>\\n\\n<details>\\n  <summary>TooltipContext</summary>\\n\\nThis context provides access to `@visx/tooltip`s `useTooltip` state, including whether the tooltip\\nis visible (`tooltipOpen`), tooltlip position (`tooltipLeft`, `tooltipTop`),\\n`tooltipData: { nearestDatum, datumByKey }` described above, and functions to update context\\n(`hideTooltip`, `showTooltip`, and `updateTooltip`).\\n\\n</details>\\n\\n<hr />\\n\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uL3Zpc3gteHljaGFydC9SZWFkbWUubWQ/ZjFkYyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUFlLHc5QkFBeTVCLHdIQUF3SCxzQkFBc0Isd0JBQXdCLHlCQUF5QixNQUFNLHlCQUF5QixNQUFNLHlCQUF5QixNQUFNLHlCQUF5QixNQUFNLHdCQUF3QixLQUFLLHdCQUF3Qix5QkFBeUIsTUFBTSx5QkFBeUIsTUFBTSx5QkFBeUIsTUFBTSx5QkFBeUIsTUFBTSx5QkFBeUIsS0FBSyxxQkFBcUIsb0RBQW9ELCtDQUErQyxJQUFJLFVBQVUsZ0JBQWdCLFVBQVUsa0JBQWtCLDJFQUEyRSxNQUFNLFdBQVcsRUFBRSxzREFBc0QsTUFBTSxFQUFFLGFBQWEsc0RBQXNELE1BQU0sRUFBRSxhQUFhLG1KQUFtSixFQUFFLDBCQUEwQiw4Q0FBOEMsbURBQW1ELGdCQUFnQiw2QkFBNkIsK0JBQStCLG9EQUFvRCxhQUFhLEtBQUssYUFBYSxvREFBb0QsMEJBQTBCLDBCQUEwQixxL0NBQXEvQyxVQUFVLHFuQkFBcW5CLHNCQUFzQixzQkFBc0IsVUFBVSw0QkFBNEIsNEJBQTRCLHNEQUFzRCx5Q0FBeUMsb0RBQW9ELHFHQUFxRyxpQ0FBaUMsK0JBQStCLCtDQUErQyxpQ0FBaUMsaUNBQWlDLGlDQUFpQyx1QkFBdUIsbUNBQW1DLDBCQUEwQix1RkFBdUYsR0FBRyxFQUFFLDBCQUEwQixZQUFZLGsyQkFBazJCLGdiQUFnYixVQUFVLDhEQUE4RCxTQUFTLDhQQUE4UCxpQkFBaUIsK0VBQStFLDJEQUEyRCxTQUFTLDhGQUE4RiwrQkFBK0IseURBQXlELCtEQUErRCxXQUFXLGFBQWEseUNBQXlDLHVsQ0FBdWxDLDhHQUE4RyxzQkFBc0IsdUJBQXVCLHlCQUF5QixNQUFNLHlCQUF5QixNQUFNLHlCQUF5QixLQUFLLHlCQUF5QixJQUFJLDBDQUEwQyxLQUFLLFlBQVksSUFBSSxZQUFZLElBQUksbUpBQW1KLFFBQVEsWUFBWSxhQUFhLFlBQVksYUFBYSxrQkFBa0IsV0FBVyxtQkFBbUIsRUFBRSxlQUFlLHdCQUF3QixnQkFBZ0Isa0JBQWtCLCtFQUErRSxnQ0FBZ0MsNENBQTRDLHNDQUFzQyxra0RBQWtrRCx1Q0FBdUMsc0JBQXNCLHNEQUFzRCwyQ0FBMkMsbUJBQW1CLE9BQU8sT0FBTyx1Q0FBdUMsK0NBQStDLGlEQUFpRCw4QkFBOEIsUUFBUSxPQUFPLDJCQUEyQixPQUFPLE9BQU8sd0RBQXdELDJGQUEyRiwrQkFBK0IsV0FBVyxhQUFhLFFBQVEsOEJBQThCLDBRQUEwUSwyQkFBMkIsbUlBQW1JIiwiZmlsZSI6Ii4uLy4uL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2Rpc3QvY2pzLmpzIS4uL3Zpc3gteHljaGFydC9SZWFkbWUubWQuanMiLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIiMgQHZpc3gveHljaGFydFxcblxcbkluIGNvbnRyYXN0IHRvIG90aGVyIGB2aXN4YCBwYWNrYWdlcyB3aGljaCBhcmUgbG93LWxldmVsLCB0aGlzIHBhY2thZ2Ugc2Vla3MgdG8gYWJzdHJhY3Qgc29tZSBvZiB0aGVcXG5jb21wbGV4aXR5IG9mIGNvbW1vbiB2aXN1YWxpemF0aW9uIGVuZ2luZWVyaW5nLCBhbmQgZXhwb3NlcyBhICoqaGlnaC1sZXZlbCoqIHgseSAoY2FydGVzaWFuXFxuY29vcmRpbmF0ZSkgY2hhcnQgQVBJLiBIb3dldmVyLCBpdCBpcyBpbXBsZW1lbnRlZCB1c2luZyBtb2R1bGFyaXplZCBgUmVhY3QuY29udGV4dGAgbGF5ZXJzIGZvclxcbnRoZW1lLCBjYW52YXMgZGltZW5zaW9ucywgeC95L2NvbG9yIHNjYWxlcywgZGF0YSwgZXZlbnRzLCBhbmQgdG9vbHRpcHMgd2hpY2ggYWxsb3dzIGZvciBtb3JlXFxuZXhwcmVzc2l2aXR5IGFuZCBhZHZhbmNlZCB1c2UgY2FzZXMuXFxuXFxuT3V0IG9mIHRoZSBib3ggaXQgc3VwcG9ydHMgdGhlIGZvbGxvd2luZzpcXG5cXG4tIFxcXFwqIG1hbnkgY29tbW9uIGA8KlNlcmllcyAvPmAgdHlwZXMgKGFuaW1hdGVkIG9yIG5vdCkgc3VjaCBhcyBsaW5lcywgYmFycywgZXRjLlxcbi0gXFxcXCogYDxBeGlzIC8+YCAoYW5pbWF0ZWQgb3Igbm90KVxcbi0gXFxcXCogYDxHcmlkIC8+YCAoYW5pbWF0ZWQgb3Igbm90KVxcbi0gXFxcXCogYDxBbm5vdGF0aW9uIC8+YCAoYW5pbWF0ZWQgb3Igbm90KVxcbi0gXFxcXCogYDxUb29sdGlwIC8+YFxcbi0gXFxcXCogYHRoZW1lYGluZ1xcblxcblRoZSBmb2xsb3dpbmcgaWxsdXN0cmF0ZXMgYmFzaWMgdXNhZ2UgdG8gY3JlYXRlIGFuIGFuaW1hdGVkIGxpbmUgY2hhcnQgd2l0aCBhIGJvdHRvbSBgQXhpc2AsIGBHcmlkYCxcXG5hbmQgYFRvb2x0aXBgLCB0cnkgaXQgb24gY29kZXNhbmRib3ggW2hlcmVdKHRvZG8sIHNpbXBsaWZ5IGNvZGUgYmVsb3cpOlxcblxcbmBgYHRzeFxcbmltcG9ydCB7XFxuICBBbmltYXRlZEF4aXMsIC8vIGFueSBvZiB0aGVzZSBjYW4gYmUgbm9uLWFuaW1hdGVkIGVxdWl2YWxlbnRzXFxuICBBbmltYXRlZEdyaWQsXFxuICBBbmltYXRlZExpbmVTZXJpZXMsXFxuICBYWUNoYXJ0LFxcbn0gZnJvbSAnQHZpc3gveHljaGFydCc7XFxuXFxuY29uc3QgZGF0YTEgPSBbXFxuICB7IHg6ICcyMDIwLTAxLTAxJywgeTogNTAgfSxcXG4gIHsgeDogJzIwMjAtMDEtMDInLCB5OiAxMCB9LFxcbiAgeyB4OiAnMjAyMC0wMS0wMycsIHk6IDIwIH0sXFxuICB7IHg6ICcyMDIwLTAxLTA0JywgeTogMTAgfSxcXG4gIHsgeDogJzIwMjAtMDEtMDUnLCB5OiAwIH0sXFxuXTtcXG5cXG5jb25zdCBkYXRhMiA9IFtcXG4gIHsgeDogJzIwMjAtMDEtMDEnLCB5OiAzMCB9LFxcbiAgeyB4OiAnMjAyMC0wMS0wMicsIHk6IDQwIH0sXFxuICB7IHg6ICcyMDIwLTAxLTAzJywgeTogODAgfSxcXG4gIHsgeDogJzIwMjAtMDEtMDQnLCB5OiA3MCB9LFxcbiAgeyB4OiAnMjAyMC0wMS0wNScsIHk6IDIwIH0sXFxuXTtcXG5jb25zdCBhY2Nlc3NvcnMgPSB7XFxuICB4QWNjZXNzb3I6IGQgPT4gZC54LFxcbiAgeUFjY2Vzc29yOiBkID0+IGQueSxcXG59O1xcblxcbmNvbnN0IHJlbmRlciA9ICgpID0+IChcXG4gIDxYWUNoYXJ0IGhlaWdodD17MzAwfSB4U2NhbGU9e3sgdHlwZTogJ2JhbmQnIH19IHlTY2FsZT17eyB0eXBlOiAnbGluZWFyJyB9fT5cXG4gICAgPEFuaW1hdGVkQXhpcyBvcmllbnRhdGlvbj1cXFwiYm90dG9tXFxcIiAvPlxcbiAgICA8QW5pbWF0ZWRHcmlkIGNvbHVtbnM9e2ZhbHNlfSBudW1UaWNrcz17NH0gLz5cXG4gICAgPEFuaW1hdGVkTGluZVNlcmllcyBkYXRhS2V5PVxcXCJMaW5lIDFcXFwiIGRhdGE9e2RhdGExfSB7Li4uYWNjZXNzb3JzfSAvPlxcbiAgICA8QW5pbWF0ZWRMaW5lU2VyaWVzIGRhdGFLZXk9XFxcIkxpbmUgMlxcXCIgZGF0YT17ZGF0YTJ9IHsuLi5hY2Nlc3NvcnN9IC8+XFxuICAgIDxUb29sdGlwXFxuICAgICAgc25hcFRvb2x0aXBUb0RhdHVtWFxcbiAgICAgIHNuYXBUb29sdGlwVG9EYXR1bVlcXG4gICAgICBzaG93VmVydGljYWxDcm9zc2hhaXJcXG4gICAgICBzaG93U2VyaWVzR2x5cGhzXFxuICAgICAgcmVuZGVyVG9vbHRpcD17KHsgdG9vbHRpcERhdGEsIGNvbG9yU2NhbGUgfSkgPT4gKFxcbiAgICAgICAgPGRpdj5cXG4gICAgICAgICAgPGRpdiBzdHlsZT17eyBjb2xvcjogY29sb3JTY2FsZSh0b29sdGlwRGF0YS5uZWFyZXN0RGF0dW0ua2V5KSB9fT5cXG4gICAgICAgICAgICB7dG9vbHRpcERhdGEubmVhcmVzdERhdHVtLmtleX1cXG4gICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgIHthY2Nlc3NvcnMueEFjY2Vzc29yKHRvb2x0aXBEYXRhLm5lYXJlc3REYXR1bS5kYXR1bSl9XFxuICAgICAgICAgIHsnLCAnfVxcbiAgICAgICAgICB7YWNjZXNzb3JzLnlBY2Nlc3Nvcih0b29sdGlwRGF0YS5uZWFyZXN0RGF0dW0uZGF0dW0pfVxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgKX1cXG4gICAgLz5cXG4gIDwvWFlDaGFydD5cXG4pO1xcbmBgYFxcblxcbkV4cGFuZCBzZWN0aW9ucyBmb3IgbW9yZSwgb3IgZXhwbG9yZSB0aGUgZGV0YWlsZWQgQVBJIGJlbG93LlxcblxcbjxociAvPlxcblxcbiMjIEJhc2ljIHVzYWdlXFxuXFxuPGRldGFpbHM+XFxuICA8c3VtbWFyeT5TZXJpZXMgdHlwZXM8L3N1bW1hcnk+XFxuXFxuVGhlIGZvbGxvd2luZyBgU2VyaWVzYCB0eXBlcyBhcmUgY3VycmVudGx5IHN1cHBvcnRlZCBhbmQgd2UgYXJlIGhhcHB5IHRvIHJldmlldyBvciBjb25zaWRlclxcbmFkZGl0aW9uYWwgU2VyaWVzIHR5cGVzIGluIHRoZSBmdXR1cmUuXFxuXFxufCBDb21wb25lbnQgbmFtZSAgICAgICAgfCBEZXNjcmlwdGlvbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBVc2FnZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcXG58IC0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gfFxcbnwgKEFuaW1hdGVkKUFyZWFTZXJpZXMgIHwgQ29ubmVjdCBkYXRhIHBvaW50cyB3aXRoIGEgYDxwYXRoIC8+YCwgd2l0aCBhIGNvbG9yIGZpbGwgdG8gdGhlIHplcm8gYmFzZWxpbmUgICAgICAgICAgICAgICAgICAgIHwgYDxBcmVhU2VyaWVzIC8+YCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XFxufCAoQW5pbWF0ZWQpQmFyU2VyaWVzICAgfCBSZW5kZXIgYSBgPHJlY3QgLz5gIGZvciBlYWNoIGRhdGEgcG9pbnQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgPEJhclNlcmllcyAvPmAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcXG58IChBbmltYXRlZClCYXJHcm91cCAgICB8IEdyb3VwIG11bHRpcGxlIGNoaWxkIGA8QmFyU2VyaWVzIC8+YCB2YWx1ZXMgdG9nZXRoZXIgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGA8QmFyR3JvdXA+PEJhclNlcmllcyAvPjxCYXJTZXJpZXMgLz4uLi48L0Jhckdyb3VwPmAgfFxcbnwgKEFuaW1hdGVkKUJhclN0YWNrICAgIHwgU3RhY2sgbXVsdGlwbGUgY2hpbGQgYDxCYXJTZXJpZXMgLz5gIHZhbHVlcyB0b2dldGhlciAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgYDxCYXJTdGFjaz48QmFyU2VyaWVzIC8+PEJhclNlcmllcyAvPi4uLjwvQmFyU3RhY2s+YCB8ICB8XFxufCAoQW5pbWF0ZWQpR2x5cGhTZXJpZXMgfCBSZW5kZXIgYSBgR2x5cGhgIChhbnkgc2hhcGUsIGRlZmF1bHRzIHRvIGA8Y2lyY2xlIC8+YCkgZm9yIGVhY2ggZGF0YSBwb2ludCwgZS5nLiwgYSBzY2F0dGVyIHBsb3QgfCBgPEdseXBoU2VyaWVzIHJlbmRlckdseXBoPXsoKSA9PiAuLi59IC8+YCAgICAgICAgICAgIHxcXG58IChBbmltYXRlZClMaW5lU2VyaWVzICB8IENvbm5lY3QgZGF0YSBwb2ludHMgd2l0aCBhIGA8cGF0aD5gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IGA8R2x5cGhTZXJpZXMgLz5gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfFxcblxcbkFsbCBgU2VyaWVzYCBoYXZlIGFuaW1hdGVkIGFuZCBub24tYW5pbWF0ZWQgdmFyaWFudHMgdG8gZ2l2ZSB5b3UgbW9yZSBjb250cm9sIG92ZXIgeW91ciBidW5kbGUgc2l6ZSxcXG5zdXBwb3J0IG1pc3NpbmcgKGBudWxsYCkgZGF0YSwgYW5kIGNhbiBiZSByZW5kZXJlZCB2ZXJ0aWNhbGx5IG9yIGhvcml6b250YWxseS5cXG5cXG48L2RldGFpbHM+XFxuXFxuPGRldGFpbHM+XFxuICA8c3VtbWFyeT5UaGVtaW5nPC9zdW1tYXJ5PlxcblxcbkRlZmF1bHQgYGxpZ2h0VGhlbWVgIGFuZCBgZGFya1RoZW1lYCB0aGVtZXMgYXJlIGV4cG9ydGVkIGZyb20gYEB2aXN4L3h5Y2hhcnRgIGFuZCB0aGUgdXRpbGl0eVxcbmBidWlsZENoYXJ0VGhlbWVgIGlzIGV4cG9ydGVkIHRvIHN1cHBvcnQgZWFzeSBjcmVhdGlvbiBvZiBjdXN0b20gdGhlbWVzLlxcblxcbmBgYHRzXFxuaW1wb3J0IHsgYnVpbGRUaGVtZSwgWFlDaGFydCB9IGZyb20gJ0B2aXN4L3h5Y2hhcnQnO1xcbmltcG9ydCB7IFRleHRQcm9wcyBhcyBTVkdUZXh0UHJvcHMgfSBmcm9tICdAdmlzeC90ZXh0L2xpYi9UZXh0JzsgLy8ganVzdCBmb3IgdHlwZXNcXG5cXG5jb25zdCBjdXN0b21UaGVtZSA9IGJ1aWxkVGhlbWUoe1xcbiAgLy8gY29sb3JzXFxuICBiYWNrZ3JvdW5kQ29sb3I6IHN0cmluZzsgLy8gdXNlZCBieSBUb29sdGlwLCBBbm5vdGF0aW9uXFxuICBjb2xvcnM6IHN0cmluZ1tdOyAvLyBjYXRlZ29yaWNhbCBjb2xvcnMsIG1hcHBlZCB0byBzZXJpZXMgdmlhIGBkYXRhS2V5YHNcXG5cXG4gIC8vIGxhYmVsc1xcbiAgc3ZnTGFiZWxCaWc/OiBTVkdUZXh0UHJvcHM7XFxuICBzdmdMYWJlbFNtYWxsPzogU1ZHVGV4dFByb3BzO1xcbiAgaHRtbExhYmVsPzogSFRNTFRleHRTdHlsZXM7XFxuXFxuICAvLyBsaW5lc1xcbiAgeEF4aXNMaW5lU3R5bGVzPzogTGluZVN0eWxlcztcXG4gIHlBeGlzTGluZVN0eWxlcz86IExpbmVTdHlsZXM7XFxuICB4VGlja0xpbmVTdHlsZXM/OiBMaW5lU3R5bGVzO1xcbiAgeVRpY2tMaW5lU3R5bGVzPzogTGluZVN0eWxlcztcXG4gIHRpY2tMZW5ndGg6IG51bWJlcjtcXG5cXG4gIC8vIGdyaWRcXG4gIGdyaWRDb2xvcjogc3RyaW5nO1xcbiAgZ3JpZENvbG9yRGFyazogc3RyaW5nOyAvLyB1c2VkIGZvciBheGlzIGJhc2VsaW5lIGlmIHgveXhBeGlzTGluZVN0eWxlcyBub3Qgc2V0XFxuICBncmlkU3R5bGVzPzogQ1NTUHJvcGVydGllcztcXG59KTtcXG5cXG4oKSA9PiA8WFlDaGFydCB0aGVtZT17Y3VzdG9tVGhlbWV9IC8+XFxuYGBgXFxuXFxuPC9kZXRhaWxzPlxcblxcbjxkZXRhaWxzPlxcbiAgPHN1bW1hcnk+VG9vbHRpcHM8L3N1bW1hcnk+XFxuXFxuYEB2aXN4L3Rvb2x0aXBgIGBUb29sdGlwYHMgYXJlIGludGVncmF0ZWQgaW50byBgQHZpc3gveHljaGFydGAsIGFuZCBzaG91bGQgYmUgcmVuZGVyZWQgYXMgYSBjaGlsZCBvZlxcbmBYWUNoYXJ0YCAob3IgYSBjaGlsZCB3aGVyZSBgVG9vbHRpcENvbnRleHRgIGlzIHByb3ZpZGVkKS5cXG5cXG4qKmBUb29sdGlwYCBwb3NpdGlvbmluZyoqIGlzIGhhbmRsZWQgYnkgdGhlIGBUb29sdGlwYCBpdHNlbGYsIGJhc2VkIG9uIGBUb29sdGlwQ29udGV4dGAuIGBUb29sdGlwYFxcbmlzIHJlbmRlcmVkIGluc2lkZSBhIGBQb3J0YWxgLCBhdm9pZGluZyBjbGlwcGluZyBieSBwYXJlbnQgRE9NIGVsZW1lbnRzIHdpdGggaGlnaGVyIHotaW5kZXhcXG5jb250ZXh0cy4gU2VlIHRoZSBBUEkgYmVsb3cgZm9yIGEgZnVsbCBsaXN0IG9mIGBwcm9wc2AgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGJlaGF2aW9yLCBzdWNoIGFzXFxuc25hcHBpbmcgdG8gZGF0YSBwb2ludCBwb3NpdGlvbnMgYW5kIHJlbmRlcmluZyBjcm9zcy1oYWlycy5cXG5cXG4qKmBUb29sdGlwYCBjb250ZW50KiogaXMgY29udHJvbGxlZCBieSB0aGUgc3BlY2lmaWVkIGBwcm9wLnJlbmRlclRvb2x0aXBgIHdoaWNoIGhhcyBhY2Nlc3MgdG86XFxuXFxuLSBgdG9vbHRpcERhdGEubmVhcmVzdERhdHVtYCDigJMgdGhlIGdsb2JhbGx5IGNsb3Nlc3QgYERhdHVtYCwgKiphY3Jvc3MgYWxsKiogYFNlcmllc2AncyBgZGF0YUtleWBzXFxuLSBgdG9vbHRpcERhdGEuZGF0dW1CeUtleWAg4oCTIHRoZSBjbG9zZXN0IGBEYXR1bWAgKipmb3IgZWFjaCoqIGBTZXJpZXNgJ3MgYGRhdGFLZXlgOyB0aGlzIGVuYWJsZXNcXG4gIFxcXCJzaGFyZWQgdG9vbHRpcHNcXFwiIHdoZXJlIHlvdSBjYW4gcmVuZGVyIHRoZSBuZWFyZXN0IGRhdGEgcG9pbnQgZm9yIGVhY2ggYFNlcmllc2AuXFxuLSBhIHNoYXJlZCBgY29sb3JTY2FsZWAgd2hpY2ggbWFwcyBgU2VyaWVzYCdzIGBkYXRhS2V5YHMgdG8gYHRoZW1lYCBjb2xvcnNcXG5cXG48L2RldGFpbHM+XFxuXFxuPGRldGFpbHM+XFxuICA8c3VtbWFyeT5FdmVudCBoYW5kbGVyczwvc3VtbWFyeT5cXG5cXG5UaGUgZm9sbG93aW5nIGBQb2ludGVyRXZlbnRgcyAoaGFuZGxpbmcgYm90aCBgTW91c2VFdmVudGBzIGFuZCBgVG91Y2hFdmVudGBzKSBhcmUgY3VycmVudGx5XFxuc3VwcG9ydGVkLiBUaGV5IG1heSBiZSBzZXQgb24gaW5kaXZpZHVhbCBgU2VyaWVzYCBjb21wb25lbnRzIChlLmcuLFxcbmA8QmFyU2VyaWVzIG9uUG9pbnRlck1vdmU9eygpID0+IC4uLn0gLz5gKSwgb3IgYXQgdGhlIGNoYXJ0IGxldmVsIChlLmcuLFxcbmA8WFlDaGFydCBvblBvaW50ZXJNb3ZlPXsoKSA9PiB7fX0gLz5gKSBpbiB3aGljaCBjYXNlIHRoZXkgYXJlIGludm9rZWQgb25jZSBmb3IgX2V2ZXJ5XyBgKlNlcmllc2AuXFxuVG8gKipkaXNhYmxlKiogZXZlbnQgZW1pdHRpbmcgZm9yIGFueSBgU2VyaWVzYCBzZXQgYDwqU2VyaWVzIGVuYWJsZUV2ZW50cz1mYWxzZSAvPmAuXFxuXFxuQmVsb3csIGBIYW5kbGVyUGFybXNgIGhhcyB0aGUgZm9sbG93aW5nIHR5cGUgc2lnbmF0dXJlOlxcblxcbmBgYHRzXFxudHlwZSBFdmVudEhhbmRsZXJQYXJhbXM8RGF0dW0+ID0ge1xcbiAgZGF0dW06IERhdHVtOyAvLyBuZWFyZXN0IERhdHVtIHRvIGV2ZW50LCBmb3IgU2VyaWVzIHdpdGggYGRhdGFLZXk9a2V5YFxcbiAgZGlzdGFuY2VYOiBudW1iZXI7IC8vIHggZGlzdGFuY2UgYmV0d2VlbiBldmVudCBhbmQgRGF0dW0sIGluIHB4XFxuICBkaXN0YW5jZVk7OiBudW1iZXI7IC8vIHkgZGlzdGFuY2UgYmV0d2VlbiBldmVudCBhbmQgRGF0dW0sIGluIHB4XFxuICBldmVudDogUmVhY3QuUG9pbnRlckV2ZW50IHwgUmVhY3QuRm9jdXNFdmVudDsgLy8gdGhlIGV2ZW50XFxuICBpbmRleDogbnVtYmVyOyAvLyBpbmRleCBvZiBEYXR1bSBpbiBTZXJpZXMgYGRhdGFgIGFycmF5XFxuICBrZXk6IHN0cmluZzsgLy8gYGRhdGFLZXlgIG9mIFNlcmllcyB0byB3aGljaCBgRGF0dW1gIGJlbG9uZ3NcXG4gIHN2Z1BvaW50OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07IC8vIGV2ZW50IHBvc2l0aW9uIGluIHN2Zy1jb29yZGluYXRlc1xcbn07XFxuYGBgXFxuXFxufCBQcm9wIG5hbWUgICAgICAgfCBTaWduYXR1cmUgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCBgWFlDaGFydGAgc3VwcG9ydCB8IGAqU2VyaWVzYCBzdXBwb3J0IHxcXG58IC0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSB8IC0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0tLS0tLS0tLS0gfFxcbnwgYG9uUG9pbnRlck1vdmVgIHwgYChwYXJhbXM6IEV2ZW50SGFuZGxlclBhcmFtczxEYXR1bT4pID0+IHZvaWRgIHwg4pyFICAgICAgICAgICAgICAgIHwg4pyFICAgICAgICAgICAgICAgIHxcXG58IGBvblBvaW50ZXJPdXRgICB8IGAoZXZlbnQ6IFJlYWN0LlBvaW50ZXJFdmVudCkgPT4gdm9pZGAgICAgICAgICB8IOKchSAgICAgICAgICAgICAgICB8IOKchSAgICAgICAgICAgICAgICB8XFxufCBgb25Qb2ludGVyVXBgICAgfCBgKHBhcmFtczogRXZlbnRIYW5kbGVyUGFyYW1zPERhdHVtPikgPT4gdm9pZGAgfCDinIUgICAgICAgICAgICAgICAgfCDinIUgICAgICAgICAgICAgICAgfFxcbnwgYG9uRm9jdXNgICAgICAgIHwgYChwYXJhbXM6IEV2ZW50SGFuZGxlclBhcmFtczxEYXR1bT4pID0+IHZvaWRgIHwg4p2MICAgICAgICAgICAgICAgIHwg4pyFICAgICAgICAgICAgICAgIHxcXG58IGBvbkJsdXJgICAgICAgICB8IGAoZXZlbnQ6IFJlYWN0LlRvdWNoRXZlbnQpID0+IHZvaWRgICAgICAgICAgICB8IOKdjCAgICAgICAgICAgICAgICB8IOKchSAgICAgICAgICAgICAgICB8XFxuXFxuPC9kZXRhaWxzPlxcblxcbjxkZXRhaWxzPlxcbiAgPHN1bW1hcnk+QW5ub3RhdGlvbnM8L3N1bW1hcnk+XFxuXFxuQ29tcG9zYWJsZSBgQHZpc3gvYW5ub3RhdGlvbnNgIGFubm90YXRpb25zIGFyZSBpbnRlZ3JhdGVkIGludG8gYEB2aXN4L3h5Y2hhcnRgIGFuZCB1c2UgaXRzIHRoZW1lIGFuZFxcbmRpbWVuc2lvbiBjb250ZXh0LiBUaGVzZSBjb21wb25lbnRzIGFsbG93IGZvciBhbm5vdGF0aW9uIG9mIGluZGl2aWR1YWwgcG9pbnRzIHVzaW5nXFxuYEFubm90YXRpb25DaXJjbGVTdWJqZWN0YCwgb3IgeC0gb3IgeS10aHJlc2hvbGRzIHVzaW5nIGBBbm5vdGF0aW9uTGluZVN1YmplY3RgLlxcblxcbmBgYHRzeFxcbmltcG9ydCB7XFxuICBYWUNoYXJ0LFxcbiAgQW5pbWF0ZWRBbm5vdGF0aW9uLFxcbiAgQW5ub3RhdGlvbkxhYmVsLFxcbiAgQW5ub3RhdGlvbkNvbm5lY3RvcixcXG4gIEFubm90YXRpb25DaXJjbGVTdWJqZWN0LFxcbn0gZnJvbSAnQHZpc3gveHljaGFydCc7XFxuXFxuY29uc3QgZGF0YSA9IFtcXG4gIHsgeDogJzIwMjAtMDEtMDEnLCB5OiA1MCB9LFxcbiAgeyB4OiAnMjAyMC0wMS0wMicsIHk6IDEwIH0sXFxuICB7IHg6ICcyMDIwLTAxLTAzJywgeTogMjAgfSxcXG5dO1xcblxcbigpID0+IChcXG4gIDxYWUNoYXJ0IHsuLi59PlxcbiAgICA8TGluZVNlcmllcyBkYXRhS2V5PVxcXCJsaW5lXFxcIiBkYXRhPXtkYXRhfSB4QWNjZXNzb3I9ey4uLn0geUFjY2Vzc29yPXsuLi59IC8+XFxuICAgIDxBbmltYXRlZEFubm90YXRpb25cXG4gICAgICBkYXRhS2V5PVxcXCJsaW5lXFxcIiAvLyB1c2UgdGhpcyBTZXJpZXMncyBhY2Nlc3NvciBmdW5jdGlvbnMsIGFsdGVybmF0aXZlbHkgc3BlY2lmeSB4L3lBY2Nlc3NvciBoZXJlXFxuICAgICAgZGF0dW09e2RhdGFbMF19XFxuICAgICAgZHg9e2xhYmVsWE9mZnNldH1cXG4gICAgICBkeT17bGFiZWxZT2Zmc2V0fVxcbiAgICAgIGVkaXRhYmxlPXtpc0VkaXRhYmxlfVxcbiAgICAgIG9uRHJhZ0VuZD17KHsgeCwgeSwgZHgsIGR5IH0pID0+IC8qKiBoYW5kbGUgZWRpdCAqL31cXG4gICAgPlxcbiAgICAgIHsvKiogVGV4dCBsYWJlbCAqL31cXG4gICAgICA8QW5ub3RhdGlvbkxhYmVsIHRpdGxlPVxcXCJNeSBwb2ludFxcXCIgc3VidGl0bGU9XFxcIk1vcmUgZGVldHNcXFwiIC8+XFxuICAgICAgey8qKiBEcmF3IGNpcmNsZSBhcm91bmQgcG9pbnQgKi99XFxuICAgICAgPEFubm90YXRpb25DaXJjbGVTdWJqZWN0IC8+XFxuICAgICAgey8qKiBDb25uZWN0IGxhYmVsIHRvIENpcmNsZVN1YmplY3QgKi99XFxuICAgICAgPEFubm90YXRpb25Db25uZWN0b3IgLz5cXG4gICAgPC9BbmltYXRlZEFubm90YXRpb24+XFxuICA8L1hZQ2hhcnQ+XFxuKVxcblxcbmBgYFxcblxcbjwvZGV0YWlscz5cXG5cXG48aHIgLz5cXG5cXG4jIyBBZHZhbmNlZCB1c2FnZVxcblxcbjxkZXRhaWxzPlxcbiAgPHN1bW1hcnk+RXhhbXBsZXM8L3N1bW1hcnk+XFxuXFxuYFhZQ2hhcnRgIGlzIGltcGxlbWVudGVkIHVzaW5nIG1vZHVsYXJpemVkIGBSZWFjdC5jb250ZXh0YCBsYXllcnMgZm9yIHNjYWxlcywgY2FudmFzIGRpbWVuc2lvbnMsXFxuZGF0YSwgZXZlbnRzLCBhbmQgdG9vbHRpcHMgd2hpY2ggZW5hYmxlcyBtb3JlIGFkdmFuY2VkIHVzYWdlIHRoYW4gbWFueSBvdGhlciBjaGFydC1sZXZlbFxcbmFic3RyYWN0aW9ucy5cXG5cXG5CeSBkZWZhdWx0IGBYWUNoYXJ0YCByZW5kZXJzIGFsbCBjb250ZXh0IHByb3ZpZGVycyBpZiBhIGdpdmVuIGNvbnRleHQgaXMgbm90IGF2YWlsYWJsZSwgYnV0IHlvdSBjYW5cXG5zaGFyZSBjb250ZXh0IGFjcm9zcyBtdWx0aXBsZSBgWFlDaGFydGBzIHRvIGltcGxlbWVudCBmdW5jdGlvbmFsaXR5IHN1Y2ggYXMgbGlua2VkIHRvb2x0aXBzLCBzaGFyZWRcXG50aGVtZXMsIG9yIHNoYXJlZCBkYXRhLlxcblxcbi0g8J+UnCBDdXN0b20gY2hhcnQgYmFja2dyb3VuZCB1c2luZyB0aGVtZSBhbmQgY2hhcnQgZGltZW5zaW9uc1xcbi0g8J+UnCBMaW5rZWQgdG9vbHRpcHNcXG4tIPCflJwgUHJvZ3JhbW1hdGljYWxseSBjb250cm9sIHRvb2x0aXBzXFxuXFxuPC9kZXRhaWxzPlxcblxcbjxkZXRhaWxzPlxcbiAgPHN1bW1hcnk+RGF0YUNvbnRleHQ8L3N1bW1hcnk+XFxuXFxuVGhpcyBjb250ZXh0IHByb3ZpZGVzIGNoYXJ0IGNhbnZhcyBkaW1lbnNpb25zIChgd2lkdGhgLCBgaGVpZ2h0YCwgYW5kIGBtYXJnaW5gKSwgeC95L2NvbG9yIHNjYWxlcyxcXG5hbmQgYSBkYXRhIHJlZ2lzdHJ5LiBUaGUgZGF0YSByZWdpc3RyeSBpbmNsdWRlcyBkYXRhIGZyb20gYWxsIGNoaWxkIGAqU2VyaWVzYCwgYW5kIHgveS9jb2xvciBzY2FsZXNcXG5hcmUgdXBkYXRlZCBhY2NvcmRpbmdseSBhY2NvdW50aW5nIGZvciBjYW52YXMgZGltZW5zaW9ucy5cXG5cXG48L2RldGFpbHM+XFxuXFxuPGRldGFpbHM+XFxuICA8c3VtbWFyeT5UaGVtZUNvbnRleHQ8L3N1bW1hcnk+XFxuXFxuVGhpcyBjb250ZXh0IHByb3ZpZGVzIGFuIGBYWUNoYXJ0YCB0aGVtZSwgaXRzIHVzZWQgYnkgYWxsIHZpc3VhbCBlbGVtZW50cyB0aGF0IGNvbXBvc2UgYSBjaGFydCwgYW5kXFxuY2FuIGJlIHVzZWQgdG8gcmVuZGVyIGN1c3RvbSB2aXN1YWwgZWxlbWVudHMgdGhhdCBhcmUgb24gdGhlbWUuXFxuXFxuPC9kZXRhaWxzPlxcblxcbjxkZXRhaWxzPlxcbiAgPHN1bW1hcnk+RXZlbnRFbWl0dGVyQ29udGV4dDwvc3VtbWFyeT5cXG5cXG5UaGlzIGNvbnRleHQgcHJvdmlkZXMgYW4gZXZlbnQgcHVibGlzaGluZyAvIHN1YnNjcmlwdGlvbiBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgdmlhIHRoZVxcbmB1c2VFdmVudEVtaXR0ZXJgIGhvb2suIGBTZXJpZXNgIGFuZCBgWFlDaGFydGAgZXZlbnRzLCBpbmNsdWRpbmcgdG9vbHRpcCB1cGRhdGVzLCBhcmUgZW1pdHRlZCBhbmRcXG5oYW5kbGVkIHdpdGggdGhyb3VnaCB0aGlzIGNvbnRleHQuXFxuXFxuYGBgdHN4XFxuaW1wb3J0IHsgdXNlRXZlbnRFbWl0dGVyLCBFdmVudEVtaXR0ZXJDb250ZXh0IH0gZnJvbSAnQHZpc3gveHljaGFydCc7XFxuXFxuY29uc3QgZXZlbnRTb3VyY2VJZCA9ICdvcHRpb25hbC1zb3VyY2UtaWQtZmlsdGVyJztcXG5cXG4oKSA9PiAoXFxuICA8RXZlbnRFbWl0dGVyQ29udGV4dD5cXG4gICAgey8qKiBlbWl0IGV2ZW50cyAqL31cXG4gICAgeygpID0+IHtcXG4gICAgICBjb25zdCBlbWl0ID0gdXNlRXZlbnRFbWl0dGVyKCk7XFxuICAgICAgcmV0dXJuIChcXG4gICAgICAgIDxidXR0b24gb25Qb2ludGVyVXA9e2V2ZW50ID0+IGVtaXQoJ3BvaW50ZXJ1cCcsIGV2ZW50LCBldmVudFNvdXJjZUlkKX0+ZW1pdCBldmVudDwvYnV0dG9uPlxcbiAgICAgICk7XFxuICAgIH19XFxuICAgIHsvKiogc3Vic2NyaWJlIHRvIGV2ZW50cyAqL31cXG4gICAgeygpID0+IHtcXG4gICAgICBjb25zdCBbY2xpY2tDb3VudCwgc2V0Q2xpY2tDb3VudF0gPSB1c2VTdGF0ZSgwKTtcXG4gICAgICB1c2VFdmVudEVtaXR0ZXIoJ3BvaW50ZXJVcCcsICgpID0+IHNldENsaWNrQ291bnQoY2xpY2tDb3VudCArIDEpLCBbZXZlbnRTb3VyY2VJZF0pO1xcblxcbiAgICAgIHJldHVybiA8ZGl2PlByZXNzZWQge2NsaWNrQ291bnR9IHRpbWVzPC9kaXY+O1xcbiAgICB9fVxcbiAgPC9FdmVudEVtaXR0ZXJDb250ZXh0Plxcbik7XFxuYGBgXFxuXFxuPC9kZXRhaWxzPlxcblxcbjxkZXRhaWxzPlxcbiAgPHN1bW1hcnk+VG9vbHRpcENvbnRleHQ8L3N1bW1hcnk+XFxuXFxuVGhpcyBjb250ZXh0IHByb3ZpZGVzIGFjY2VzcyB0byBgQHZpc3gvdG9vbHRpcGBzIGB1c2VUb29sdGlwYCBzdGF0ZSwgaW5jbHVkaW5nIHdoZXRoZXIgdGhlIHRvb2x0aXBcXG5pcyB2aXNpYmxlIChgdG9vbHRpcE9wZW5gKSwgdG9vbHRsaXAgcG9zaXRpb24gKGB0b29sdGlwTGVmdGAsIGB0b29sdGlwVG9wYCksXFxuYHRvb2x0aXBEYXRhOiB7IG5lYXJlc3REYXR1bSwgZGF0dW1CeUtleSB9YCBkZXNjcmliZWQgYWJvdmUsIGFuZCBmdW5jdGlvbnMgdG8gdXBkYXRlIGNvbnRleHRcXG4oYGhpZGVUb29sdGlwYCwgYHNob3dUb29sdGlwYCwgYW5kIGB1cGRhdGVUb29sdGlwYCkuXFxuXFxuPC9kZXRhaWxzPlxcblxcbjxociAvPlxcblwiOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///../../node_modules/raw-loader/dist/cjs.js!../visx-xychart/Readme.md\n");

/***/ })

})